// Generated by CoffeeScript 1.9.3
(function() {
  var Camera, Map, Matrix, cam, frame, i, j, k, l, map, numPoints, ref, ref1, rotMatrix;

  Camera = (function() {
    function Camera(w, h, fov, x, y, z, tx, ty, tz) {
      var ref;
      this.canvases = document.getElementsByTagName('canvas');
      this.canvas = this.canvases[0];
      this.canvas.height = h;
      this.canvas.width = w;
      this.canvas.style.height = h + 'px';
      this.canvas.style.width = w + 'px';
      this.ctx = this.canvas.getContext('2d');
      ref = {
        w: w,
        h: h,
        fov: fov,
        x: x,
        y: y,
        z: z,
        tx: tx,
        ty: ty,
        tz: tz
      }, this.w = ref.w, this.h = ref.h, this.fov = ref.fov, this.x = ref.x, this.y = ref.y, this.z = ref.z, this.tx = ref.tx, this.ty = ref.ty, this.tz = ref.tz;
      this.origin = {
        x: this.w / 2,
        y: this.h / 2
      };
    }

    Camera.prototype.clear = function() {
      this.ctx.fillStyle = 'black';
      return this.ctx.fillRect(0, 0, this.w, this.h);
    };

    Camera.prototype.trace = function(map) {
      var dpx, dpy, dx, dy, dz, iter, k, l, len, len1, line, point, px, py, ref, ref1, results, spoints, tx, ty, tz;
      this.ctx.fillStyle = 'white';
      this.ctx.strokeStyle = 'white';
      spoints = {};
      ref = map.points;
      for (iter = k = 0, len = ref.length; k < len; iter = ++k) {
        point = ref[iter];
        dx = point[0] - this.x;
        dy = point[1] - this.y;
        dz = point[2] - this.z;
        tx = Math.atan(dx / dz + this.tx);
        ty = Math.atan(dy / dz + this.ty);
        tz = this.tz;
        dpx = this.fov * this.h * tx;
        dpy = this.fov * this.h * ty;
        px = dpx + this.origin.x;
        py = this.origin.y - dpy;
        spoints[iter] = [px, py];
      }
      ref1 = map.lines;
      results = [];
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        line = ref1[l];
        this.ctx.beginPath();
        this.ctx.moveTo(spoints[line[0]][0], spoints[line[0]][1]);
        this.ctx.lineTo(spoints[line[1]][0], spoints[line[1]][1]);
        results.push(this.ctx.stroke());
      }
      return results;
    };

    return Camera;

  })();

  Map = (function() {
    function Map() {
      this.points = [];
      this.lines = [];
    }

    Map.prototype.applyMatrix = function(rotMatrix) {
      var iter, k, len, origMatrix, point, ref, resMatrix, results;
      ref = this.points;
      results = [];
      for (iter = k = 0, len = ref.length; k < len; iter = ++k) {
        point = ref[iter];
        origMatrix = new Matrix(1, 3, point);
        resMatrix = rotMatrix.mul(origMatrix);
        results.push(this.points[iter] = resMatrix.toArray()[0]);
      }
      return results;
    };

    return Map;

  })();

  Matrix = (function() {
    function Matrix(w, h, els) {
      var ref;
      ref = {
        w: w,
        h: h,
        els: els
      }, this.w = ref.w, this.h = ref.h, this.els = ref.els;
    }

    Matrix.prototype.get = function(c, r) {
      return this.els[r * this.h + c];
    };

    Matrix.prototype.mul = function(m2) {
      var intSum, k, l, lCol, m, n, rRow, ref, ref1, ref2, resEls;
      if (this.w !== m2.h) {
        throw new Error('Cannot multiply this matrix: ' + this.w + ' by ' + m2.h);
      }
      resEls = [];
      for (lCol = k = 0, ref = this.h - 1; 0 <= ref ? k <= ref : k >= ref; lCol = 0 <= ref ? ++k : --k) {
        for (rRow = l = 0, ref1 = m2.w - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; rRow = 0 <= ref1 ? ++l : --l) {
          intSum = 0;
          for (n = m = 0, ref2 = this.w - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; n = 0 <= ref2 ? ++m : --m) {
            intSum += this.get(lCol, n) * m2.get(n, rRow);
          }
          resEls[lCol * this.h + rRow] = intSum;
        }
      }
      return new Matrix(m2.w, this.h, resEls);
    };

    Matrix.prototype.toArray = function() {
      var arr, k, l, ref, ref1, x, y;
      arr = [];
      for (x = k = 0, ref = this.w - 1; 0 <= ref ? k <= ref : k >= ref; x = 0 <= ref ? ++k : --k) {
        arr[x] = [];
        for (y = l = 0, ref1 = this.h - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; y = 0 <= ref1 ? ++l : --l) {
          arr[x][y] = this.get(x, y);
        }
      }
      return arr;
    };

    return Matrix;

  })();

  Matrix.createRot = function(tx, ty, tz) {
    var cx, cy, cz, sx, sy, sz;
    sx = Math.sin(tx);
    sy = Math.sin(ty);
    sz = Math.sin(tz);
    cx = Math.cos(tx);
    cy = Math.cos(ty);
    cz = Math.cos(tz);
    return new Matrix(3, 3, [cz * cy, -sz * cy, sy, sy * sx * cz + cx * sz, -sy * sx * sz + cx * cz, -sx * cy, -sy * cx * cz + sx * sz, sy * cx * sz + cz * sx, cx * cy]);
  };

  cam = new Camera(window.innerWidth, window.innerHeight, Math.PI / 2, 0.5, 0.5, -5, 0, 0, 0);

  map = new Map;

  numPoints = Math.floor(Math.random() * 20);

  for (i = k = 1, ref = numPoints; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
    map.points.push([Math.floor(Math.random() * 20 - 10) / 10, Math.floor(Math.random() * 20 - 10) / 10, Math.floor(Math.random() * 20 - 10) / 10]);
    for (j = l = 0, ref1 = i - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
      map.lines.push([i - 1, j]);
    }
  }

  rotMatrix = Matrix.createRot(0.01, 0.01, 0.01);

  frame = function() {
    map.applyMatrix(rotMatrix);
    cam.clear();
    cam.trace(map);
    return window.requestAnimationFrame(frame);
  };

  frame();

}).call(this);
